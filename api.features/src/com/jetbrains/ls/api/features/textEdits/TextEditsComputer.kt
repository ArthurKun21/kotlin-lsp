package com.jetbrains.ls.api.features.textEdits

import com.github.difflib.DiffUtils
import com.github.difflib.patch.Patch
import com.jetbrains.lsp.protocol.Position
import com.jetbrains.lsp.protocol.Range
import com.jetbrains.lsp.protocol.TextEdit

object TextEditsComputer {
    // generated by ai :)
    fun computeTextEdits(oldText: String, newText: String): List<TextEdit> {
        // 1) Convert both strings to a list of characters (including '\n')
        val oldChars = oldText.toList()
        val newChars = newText.toList()

        // 2) Compute the diff
        val patch: Patch<Char> = DiffUtils.diff(oldChars, newChars)

        // 3) Precompute line breaks in oldText to quickly get line/character from an index
        //    We'll build an array of the cumulative indices of newlines.
        //    For example, if oldText = "abc\ndef\ng", then lineBreakPositions might be [3, 7].
        //    So offsets <= 3 are line 0, offsets <= 7 are line 1, etc.
        val lineBreakPositions = mutableListOf<Int>()
        oldText.forEachIndexed { i, c ->
            if (c == '\n') {
                lineBreakPositions.add(i)
            }
        }

        /**
         * Helper to map a 0-based character offset in oldText into (line, character).
         */
        fun offsetToPosition(offset: Int): Position {
            // You can do a binary search for performance; here we just do a linear scan for clarity
            var line = 0
            for (br in lineBreakPositions) {
                if (offset <= br) break
                line++
            }

            // If line is zero, `offset` is the character index in line 0.
            // If line > 0, we can figure out how many chars we've passed up to line-1
            val lineStartOffset = if (line == 0) 0 else lineBreakPositions[line - 1] + 1
            val characterInLine = offset - lineStartOffset
            return Position(line, characterInLine)
        }

        val edits = mutableListOf<TextEdit>()

        // 4) Build a TextEdit for each delta
        for (delta in patch.deltas) {
            // The delta tells us which region in oldText is replaced,
            // and what the new text (from newText) should be.

            // Original chunk
            val source = delta.source
            val sourcePos = source.position   // start index in oldChars
            val sourceSize = source.size()

            // Revised chunk
            val target = delta.target
            val newSegment = target.lines.joinToString(separator = "") { it.toString() }

            // Convert the old range: [sourcePos, sourcePos + sourceSize) to LSP Range
            val startPos = offsetToPosition(sourcePos)
            val endPos = offsetToPosition(sourcePos + sourceSize)

            // Create the edit
            edits.add(
                TextEdit(
                    range = Range(startPos, endPos),
                    newText = newSegment
                )
            )
        }

        return edits
    }
}